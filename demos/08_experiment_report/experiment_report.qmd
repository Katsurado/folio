---
title: "Bayesian Optimization of ATRP Polymerization Conditions"
subtitle: "A Multi-Objective Approach Using Gaussian Process Surrogates"
author:
  - name: Research Team
    affiliations:
      - name: Department of Chemistry
        city: Pittsburgh
        state: PA
date: today
abstract: |
  We report the application of Bayesian optimization to the multi-objective
  optimization of atom transfer radical polymerization (ATRP) conditions.
  Using Folio, an electronic lab notebook with integrated Bayesian optimization,
  we systematically explored a four-dimensional parameter space to identify
  Pareto-optimal conditions that balance high molecular weight with narrow
  dispersity. A multi-task Gaussian process surrogate model captured correlations
  between objectives, enabling efficient exploration with only 20 experiments.
  The identified Pareto front provides actionable guidance for selecting
  synthesis conditions based on application requirements.
keywords:
  - Bayesian optimization
  - ATRP
  - Polymer synthesis
  - Multi-objective optimization
  - Gaussian processes
format:
  pdf:
    documentclass: article
    papersize: letter
    fontsize: 11pt
    geometry:
      - margin=1in
      - headheight=14pt
    number-sections: true
    colorlinks: true
    linkcolor: blue
    citecolor: blue
    urlcolor: blue
    toc: true
    toc-depth: 2
    lof: true
    lot: true
    header-includes:
      - \usepackage{mhchem}
      - \usepackage{siunitx}
      - \usepackage{booktabs}
      - \usepackage{float}
      - \floatplacement{figure}{H}
      - \floatplacement{table}{H}
  html:
    toc: true
    toc-depth: 2
    code-fold: true
    theme: cosmo
bibliography: references.bib
execute:
  echo: false
  warning: false
jupyter: python3
---

```{python}
#| label: setup
#| include: false
import tempfile
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from IPython.display import Markdown, display

from folio.api import Folio
from folio.core.config import RecommenderConfig, TargetConfig
from folio.core.schema import InputSpec, OutputSpec

# Matplotlib settings for publication
plt.rcParams.update({
    'font.size': 10,
    'axes.labelsize': 11,
    'axes.titlesize': 12,
    'xtick.labelsize': 9,
    'ytick.labelsize': 9,
    'legend.fontsize': 9,
    'figure.dpi': 150,
})

# Initialize Folio
db_path = tempfile.NamedTemporaryFile(suffix=".db", delete=False).name
folio = Folio(db_path=db_path)
```

# Introduction

Atom transfer radical polymerization (ATRP) is a powerful controlled radical
polymerization technique that enables synthesis of polymers with well-defined
molecular weights and narrow dispersities [@matyjaszewski2001atom]. The reaction
involves equilibrium between dormant alkyl halide species and active radicals,
mediated by a transition metal catalyst:

$$
\ce{P_n-X + Cu^{I}/L <=>[$k_{\text{act}}$][$k_{\text{deact}}$] P_n^. + X-Cu^{II}/L}
$$ {#eq-atrp}

where $\ce{P_n-X}$ is the dormant polymer chain, $\ce{Cu^{I}/L}$ is the activator
complex, and $\ce{P_n^.}$ is the propagating radical.

Optimizing ATRP conditions requires balancing multiple objectives:

- **Maximize molecular weight** ($M_n$) for improved material properties
- **Minimize dispersity** ($\text{Đ} = M_w/M_n$) for uniform chain lengths
- **Maximize conversion** for efficient monomer utilization

These objectives often conflict—higher molecular weights typically require
conditions that broaden the molecular weight distribution. Multi-objective
Bayesian optimization provides a principled approach to mapping this trade-off
[@daulton2020differentiable].

## Bayesian Optimization Framework

Bayesian optimization constructs a probabilistic surrogate model of the
objective function and uses an acquisition function to balance exploration
and exploitation [@jones1998efficient]. For a Gaussian process (GP) surrogate
with posterior mean $\mu(\mathbf{x})$ and variance $\sigma^2(\mathbf{x})$, the
Expected Improvement (EI) acquisition function is:

$$
\text{EI}(\mathbf{x}) = \mathbb{E}\left[\max(f(\mathbf{x}) - f^*, 0)\right] = \sigma(\mathbf{x})\left[\phi(Z) + Z\Phi(Z)\right]
$$ {#eq-ei}

where $Z = (\mu(\mathbf{x}) - f^*)/\sigma(\mathbf{x})$, $\phi$ is the standard
normal PDF, and $\Phi$ is the CDF [@williams2006gaussian].

For multi-objective optimization, we employ the Noisy Expected Hypervolume
Improvement (NEHVI) acquisition function, which maximizes the expected
improvement in the hypervolume dominated by the Pareto front
[@daulton2020differentiable].

# Methods

## Experimental Design

```{python}
#| label: create-project
# Create project
inputs = [
    InputSpec("HO_EBiB", "continuous", bounds=(0.5, 2.0), units="equiv"),
    InputSpec("MB", "continuous", bounds=(50.0, 200.0), units="equiv"),
    InputSpec("CuBr2_L", "continuous", bounds=(0.01, 0.1), units="equiv"),
    InputSpec("TEOA", "continuous", bounds=(0.1, 1.0), units="equiv"),
]
outputs = [
    OutputSpec("conversion", units="%"),
    OutputSpec("Mn_app", units="g/mol"),
    OutputSpec("dispersity"),
]
target_configs = [
    TargetConfig(objective="Mn_app", objective_mode="maximize"),
    TargetConfig(objective="dispersity", objective_mode="minimize"),
]
reference_point = [5000.0, 2.0]

folio.create_project(
    name="atrp_report",
    inputs=inputs,
    outputs=outputs,
    target_configs=target_configs,
    reference_point=reference_point,
    recommender_config=RecommenderConfig(
        type="bayesian",
        surrogate="multitask_gp",
        mo_acquisition="nehvi",
        n_initial=5,
    ),
)
```

The ATRP reaction was optimized over a four-dimensional parameter space
(@tbl-parameters). Reagent stoichiometries were varied relative to a fixed
monomer concentration.

| Parameter | Symbol | Range | Units |
|-----------|--------|-------|-------|
| Initiator (HO-EBiB) | $[\text{I}]_0$ | 0.5–2.0 | equiv |
| Monomer (MB) | $[\text{M}]_0$ | 50–200 | equiv |
| Catalyst (\ce{CuBr2}/L) | $[\text{Cu}]_0$ | 0.01–0.1 | equiv |
| Reducing agent (TEOA) | $[\text{RA}]_0$ | 0.1–1.0 | equiv |

: Experimental parameter space for ATRP optimization {#tbl-parameters}

## Analytical Methods

Monomer conversion was determined by $^1$H NMR spectroscopy (Bruker 400 MHz)
by integration of vinyl proton resonances against an internal standard.
Number-average molecular weight ($M_n$) and dispersity (Đ) were measured by
gel permeation chromatography (GPC) using THF as eluent at \SI{35}{\celsius}
with polystyrene calibration standards.

## Surrogate Model Configuration

A multi-task Gaussian process (MTGP) was employed to model correlations between
the two objectives [@balandat2020botorch]. The MTGP uses an intrinsic
coregionalization model (ICM) kernel:

$$
k((\mathbf{x}, t), (\mathbf{x}', t')) = k_{\text{RBF}}(\mathbf{x}, \mathbf{x}') \cdot B_{tt'}
$$ {#eq-icm}

where $k_{\text{RBF}}$ is a radial basis function kernel over inputs and
$\mathbf{B}$ is a positive semi-definite matrix capturing task correlations.

# Results

## Screening Phase

```{python}
#| label: add-data
# Add screening data
screening_data = [
    (1.0, 100.0, 0.05, 0.5, 78.5, 18500, 1.25),
    (1.0, 150.0, 0.05, 0.5, 72.3, 26800, 1.32),
    (1.0, 200.0, 0.05, 0.5, 65.1, 32100, 1.45),
    (0.5, 100.0, 0.05, 0.5, 85.2, 35200, 1.38),
    (2.0, 100.0, 0.05, 0.5, 91.5, 9800, 1.18),
    (1.0, 100.0, 0.01, 0.5, 45.2, 12300, 1.65),
    (1.0, 100.0, 0.1, 0.5, 92.8, 19200, 1.22),
    (1.0, 100.0, 0.05, 0.1, 52.1, 14500, 1.72),
    (1.0, 100.0, 0.05, 1.0, 88.9, 20100, 1.28),
    (0.5, 150.0, 0.08, 0.7, 76.4, 42500, 1.35),
    (0.75, 175.0, 0.06, 0.6, 71.8, 38900, 1.42),
    (1.5, 75.0, 0.04, 0.4, 82.3, 11200, 1.21),
]

for ho_ebib, mb, cubr2, teoa, conv, mn, disp in screening_data:
    folio.add_observation(
        project_name="atrp_report",
        inputs={"HO_EBiB": ho_ebib, "MB": mb, "CuBr2_L": cubr2, "TEOA": teoa},
        outputs={"conversion": conv, "Mn_app": mn, "dispersity": disp},
        tag="screening",
    )

# Run optimization
def simulate_atrp(inputs):
    ho_ebib, mb = inputs["HO_EBiB"], inputs["MB"]
    cubr2, teoa = inputs["CuBr2_L"], inputs["TEOA"]
    target_dp = mb / ho_ebib
    mn_base = target_dp * 100
    conv = min(95, 50 + 40 * cubr2 / 0.1 * teoa / 1.0) + np.random.normal(0, 2)
    mn = max(5000, mn_base * (conv / 100) + np.random.normal(0, 1000))
    disp = max(1.05, min(2.0, 1.05 + 0.3 * (1 - cubr2/0.1) + 0.2 * (1 - teoa/1.0) + 0.1 * (mb/200) + np.random.normal(0, 0.03)))
    return {"conversion": round(conv, 1), "Mn_app": round(mn, 0), "dispersity": round(disp, 2)}

np.random.seed(42)
for i in range(8):
    suggestion = folio.suggest("atrp_report")[0]
    results = simulate_atrp(suggestion)
    folio.add_observation(
        project_name="atrp_report",
        inputs=suggestion,
        outputs=results,
        tag="optimization",
    )

# Get all data
observations = folio.get_observations("atrp_report")
```

Initial screening experiments explored the parameter space boundaries to
establish baseline performance (@tbl-screening).

```{python}
#| label: tbl-screening
#| tbl-cap: "Selected screening experiments showing parameter-response relationships"
def obs_to_df(observations):
    records = []
    for obs in observations:
        record = {"Tag": obs.tag}
        record.update(obs.inputs)
        record.update(obs.outputs)
        records.append(record)
    return pd.DataFrame(records)

df = obs_to_df(observations)
screening_df = df[df["Tag"] == "screening"].head(6)

# Format for display
display_df = screening_df[["HO_EBiB", "MB", "CuBr2_L", "TEOA", "conversion", "Mn_app", "dispersity"]].copy()
display_df.columns = ["[I]₀", "[M]₀", "[Cu]₀", "[RA]₀", "Conv. (%)", "Mn (g/mol)", "Đ"]
display_df["Mn (g/mol)"] = display_df["Mn (g/mol)"].apply(lambda x: f"{x:,.0f}")
display(Markdown(display_df.to_markdown(index=False)))
```

## Optimization Campaign

Following the screening phase, Bayesian optimization guided subsequent
experiments. @fig-pareto shows the resulting Pareto front in objective space.

```{python}
#| label: fig-pareto
#| fig-cap: "Pareto front showing the trade-off between molecular weight (Mn) and dispersity (Đ). Red stars indicate Pareto-optimal solutions; gray circles are dominated points. The reference point (black square) defines the hypervolume calculation boundary."
def find_pareto_optimal(mn_values, disp_values):
    n = len(mn_values)
    is_optimal = np.ones(n, dtype=bool)
    for i in range(n):
        for j in range(n):
            if i != j:
                if mn_values[j] >= mn_values[i] and disp_values[j] <= disp_values[i]:
                    if mn_values[j] > mn_values[i] or disp_values[j] < disp_values[i]:
                        is_optimal[i] = False
                        break
    return is_optimal

mn_values = df["Mn_app"].values
disp_values = df["dispersity"].values
pareto_mask = find_pareto_optimal(mn_values, disp_values)

fig, ax = plt.subplots(figsize=(6, 4.5))

ax.scatter(mn_values[~pareto_mask], disp_values[~pareto_mask],
           c="gray", alpha=0.6, s=50, label="Dominated", edgecolors="white", linewidths=0.5)

ax.scatter(mn_values[pareto_mask], disp_values[pareto_mask],
           c="red", s=100, marker="*", label="Pareto optimal", zorder=5)

pareto_mn = mn_values[pareto_mask]
pareto_disp = disp_values[pareto_mask]
sort_idx = np.argsort(pareto_mn)
ax.plot(pareto_mn[sort_idx], pareto_disp[sort_idx], "r--", alpha=0.5, linewidth=1.5)

ax.scatter([reference_point[0]], [reference_point[1]],
           c="black", marker="s", s=80, label="Reference point", zorder=5)

ax.set_xlabel(r"$M_n$ (g/mol)")
ax.set_ylabel(r"Dispersity (Đ)")
ax.legend(loc="upper right", framealpha=0.9)
ax.grid(True, alpha=0.3, linestyle="--")
ax.invert_yaxis()

plt.tight_layout()
plt.show()
```

The optimization identified `{python} pareto_mask.sum()` Pareto-optimal
conditions from `{python} len(df)` total experiments. @tbl-pareto lists the
optimal conditions sorted by molecular weight.

```{python}
#| label: tbl-pareto
#| tbl-cap: "Pareto-optimal reaction conditions for ATRP. Conditions are sorted by decreasing molecular weight."
pareto_df = df[pareto_mask].sort_values("Mn_app", ascending=False)
display_pareto = pareto_df[["HO_EBiB", "MB", "CuBr2_L", "TEOA", "conversion", "Mn_app", "dispersity"]].copy()
display_pareto.columns = ["[I]₀", "[M]₀", "[Cu]₀", "[RA]₀", "Conv. (%)", "Mn (g/mol)", "Đ"]
display_pareto["Mn (g/mol)"] = display_pareto["Mn (g/mol)"].apply(lambda x: f"{x:,.0f}")
display(Markdown(display_pareto.to_markdown(index=False)))
```

## GP Model Analysis

The trained GP model provides predictive distributions across the parameter
space. @fig-gp-surface shows the predicted molecular weight as a function of
monomer loading and initiator concentration.

```{python}
#| label: fig-gp-surface
#| fig-cap: "Gaussian process predictions for molecular weight (left) and associated uncertainty (right) as functions of monomer ([M]₀) and initiator ([I]₀) concentrations. Catalyst and reducing agent concentrations fixed at 0.05 and 0.5 equiv, respectively. Red crosses indicate experimental observations."
folio.suggest("atrp_report")
surrogate = folio.get_recommender("atrp_report").surrogate

n_grid = 25
mb_range = np.linspace(50, 200, n_grid)
ho_range = np.linspace(0.5, 2.0, n_grid)
MB_grid, HO_grid = np.meshgrid(mb_range, ho_range)

X_grid = np.column_stack([
    HO_grid.ravel(), MB_grid.ravel(),
    np.full(n_grid**2, 0.05), np.full(n_grid**2, 0.5)
])

mean, std = surrogate.predict(X_grid)
mn_mean = mean[:, 0].reshape(n_grid, n_grid)
mn_std = std[:, 0].reshape(n_grid, n_grid)

fig, axes = plt.subplots(1, 2, figsize=(10, 4))

ax = axes[0]
c = ax.contourf(MB_grid, HO_grid, mn_mean, levels=20, cmap="viridis")
ax.scatter(df["MB"], df["HO_EBiB"], c="red", s=30, marker="x", linewidths=1.5)
ax.set_xlabel(r"$[\text{M}]_0$ (equiv)")
ax.set_ylabel(r"$[\text{I}]_0$ (equiv)")
ax.set_title(r"Predicted $M_n$ (g/mol)")
plt.colorbar(c, ax=ax)

ax = axes[1]
c = ax.contourf(MB_grid, HO_grid, mn_std, levels=20, cmap="Oranges")
ax.scatter(df["MB"], df["HO_EBiB"], c="red", s=30, marker="x", linewidths=1.5)
ax.set_xlabel(r"$[\text{M}]_0$ (equiv)")
ax.set_ylabel(r"$[\text{I}]_0$ (equiv)")
ax.set_title(r"Prediction Uncertainty (std)")
plt.colorbar(c, ax=ax)

plt.tight_layout()
plt.show()
```

# Discussion

The multi-objective optimization successfully mapped the trade-off between
molecular weight and dispersity in ATRP. Several key insights emerged:

1. **Monomer-to-initiator ratio**: As predicted by living polymerization
   kinetics ($\text{DP}_n \approx [\text{M}]_0/[\text{I}]_0 \times \text{conversion}$),
   higher monomer loadings and lower initiator concentrations yielded higher
   molecular weights, but at the cost of broader dispersity.

2. **Catalyst effects**: Higher catalyst loadings (\ce{CuBr2}/L > 0.05 equiv)
   improved dispersity control through faster deactivation, maintaining
   the living character of the polymerization (@eq-atrp).

3. **Reducing agent optimization**: TEOA concentrations of 0.5–0.7 equiv
   provided optimal balance between activator regeneration and side reactions.

The GP uncertainty maps (@fig-gp-surface, right panel) reveal regions of high
uncertainty at the parameter space boundaries, suggesting potential for further
exploration. The correlation between objectives captured by the multi-task GP
enabled efficient exploration with limited experiments.

# Conclusions

Bayesian optimization using Folio enabled systematic exploration of ATRP
parameter space with only `{python} len(df)` experiments. The identified
Pareto front (@fig-pareto) provides actionable guidance:

- For applications requiring $M_n > 35{,}000$ g/mol: accept Đ ≈ 1.35–1.45
- For applications requiring Đ < 1.25: limit $M_n$ to ~20,000 g/mol
- Compromise conditions: $M_n \approx 25{,}000$ g/mol with Đ ≈ 1.30

Future work will extend this approach to additional controlled polymerization
techniques and incorporate batch effects through hierarchical GP models.

# References

::: {#refs}
:::

```{python}
#| include: false
# Cleanup
folio.delete_project("atrp_report")
```
